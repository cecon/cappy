<?xml version="1.0" encoding="UTF-8"?>
<cappy:script name="view-current-task" version="1.0">
  <about>
    <summary>Exibir o status da task atual (progresso, prÃ³ximo step, arquivos e aÃ§Ãµes).</summary>
    <command>cappy:task:status</command>
    <notes>
      <note>NÃ£o altera nenhum arquivo; apenas lÃª .cappy/tasks/ e apresenta status.</note>
    </notes>
  </about>

  <steps>
    <step id="1.find_active_task">
      <goal>Localizar a task ativa em .cappy/tasks/.</goal>
      <logic>
        <![CDATA[
        // 1) Tentar usar o ponteiro de estado
        active_task = null
        state = optional_read_json('.cappy/state/current-task.json')
        if (state && state.currentTaskFile) {
          try {
            xml = parse_xml(read_file(state.currentTaskFile))
            active_task = { xml, task_file: state.currentTaskFile }
          } catch (e) { /* fallback para varredura */ }
        }

        // 2) Fallback: varrer tasks
        if (!active_task) {
          tasks = list_files(".cappy/tasks/*.xml")
          for (task_file in tasks) {
            xml = parse_xml(read_file(task_file))
            if (xml.metadata.status in ["em-andamento", "in-progress", "prepared", "preparing"]) {
              // Preferir a que estiver em-andamento; caso contrÃ¡rio, pegar a mais recente
              if (xml.metadata.status == "em-andamento" || xml.metadata.status == "in-progress") { active_task = { xml, task_file }; break }
              active_task = { xml, task_file }
            }
          }
        }

        if (!active_task) {
          say("âŒ Nenhuma task ativa encontrada. Use 'cappy:newtask' para criar e preparar uma task.")
          return
        }
        ]]>
      </logic>
      <output>internal.activeTask</output>
    </step>

    <step id="2.analyze_progress">
      <goal>Calcular progresso, identificar prÃ³ximo step e dependÃªncias.</goal>
      <logic>
        <![CDATA[
        xml = internal.activeTask.xml
        total_steps = count(xml.steps.step)
        completed_steps = count_where(xml.steps.step, "completed=true|concluido=true")
        current_step = find_first_where(xml.steps.step, "completed=false|concluido=false")
        progress_percentage = total_steps > 0 ? round((completed_steps / total_steps) * 100) : 0

        analysis = { total_steps, completed_steps, current_step, progress_percentage }

        // DependÃªncia do step atual (se houver)
        if (current_step && current_step['dependsOn|dependeDe']) {
          dep_id = current_step['dependsOn|dependeDe']
          dep_step = find_step_by_id(xml.steps.step, dep_id)
          if (dep_step && (dep_step.completed == false || dep_step.concluido == false)) {
            analysis.dependencyWarning = "âš ï¸ Step atual depende de: " + (dep_step.title || dep_step.titulo || dep_id)
          }
        }

        internal.taskAnalysis = analysis
        ]]>
      </logic>
      <output>internal.taskAnalysis</output>
    </step>

    <step id="3.present_status">
      <goal>Apresentar o status atual de forma clara e objetiva.</goal>
      <logic>
        <![CDATA[
        xml = internal.activeTask.xml
        analysis = internal.taskAnalysis
        title = xml.metadata.title || xml.metadados.titulo || "(sem tÃ­tulo)"
        status = xml.metadata.status || xml.metadados.status || "(sem status)"
        progress = `${analysis.completed_steps}/${analysis.total_steps} steps (${analysis.progress_percentage}%)`

        current = analysis.current_step || {}
        step_title = current.title || current.titulo || "(sem tÃ­tulo)"
        step_desc  = current.description || current.descricao || "(sem descriÃ§Ã£o)"

        // Construir lista de critÃ©rios
        criterios = []
        if (current.criteria && current.criteria.criterion) criterios = as_array(current.criteria.criterion)
        if (current.criterios && current.criterios.criterio) criterios = as_array(current.criterios.criterio)

        // Arquivos envolvidos
        files = []
        if (current.files && current.files.file) files = as_array(current.files.file)
        if (current.entrega) files = files.concat(as_array(current.entrega))

        // SaÃ­da amigÃ¡vel
        say(`# ğŸ“‹ Task Atual: ${title}\n\n## ğŸ“ˆ Progresso Geral\n- Status: ${status}\n- Progresso: ${progress}\n\n## ğŸ“ PrÃ³ximo Step\n${step_title}\nğŸ¯ Objetivo: ${step_desc}\n\nâœ… CritÃ©rios para conclusÃ£o:`)
        for (c in criterios) { say(`- ${c}`) }

        if (files.length > 0) {
          say("\n## ğŸ“ Arquivos Envolvidos")
          for (f in files) { say(`- ${f}`) }
        }

        if (analysis.dependencyWarning) {
          say(`\n${analysis.dependencyWarning}`)
        }

        say("\n## ğŸš€ AÃ§Ãµes DisponÃ­veis\n- 'vamos trabalhar' â€” Iniciar execuÃ§Ã£o do step atual\n- 'marcar step como concluÃ­do' â€” Finalizar step atual\n- 'pausar task' â€” Pausar a task temporariamente")
        ]]>
      </logic>
    </step>

    <step id="4.show_prevention_rules">
      <goal>Exibir Prevention Rules relevantes, se houver.</goal>
      <logic>
        <![CDATA[
        rules = optional_read(".cappy/prevention-rules.md")
        if (rules) {
          // NÃ£o filtra por Ã¡rea aqui para manter simples; implementaÃ§Ãµes podem evoluir o filtro
          say("\n## ğŸ›¡ï¸ Prevention Rules AplicÃ¡veis")
          say(rules)
        }
        ]]>
      </logic>
    </step>
  </steps>
</cappy:script>
