/**
/**
 * @fileoverview Simplified SQLite adapter for graph storage using sqlite3
 * @module adapters/secondary/graph/sqlite-simple-adapter
 * @since 3.0.0
 */

import * as sqlite3 from "sqlite3";
import * as fs from "fs";
import * as path from "path";

import type { GraphStorePort } from "../../../domains/graph/ports/indexing-port";
import type { DocumentChunk } from "../../../types/chunk";

/**
 * Simplified SQLite adapter using sqlite3 native bindings
 * Compatible with VS Code Extension Host
 */
export class SQLiteAdapter implements GraphStorePort {
  private readonly dbPath: string;
  private db: sqlite3.Database | null = null;
  private dbFilePath = "";

  constructor(dbPath: string) {
    this.dbPath = dbPath;
  }

  async initialize(): Promise<void> {
    console.log(`üìä Initializing SQLite database: ${this.dbPath}`);

    // Resolve file path
    let dbFilePath = this.dbPath;
    if (!path.isAbsolute(dbFilePath)) {
      dbFilePath = path.resolve(dbFilePath);
    }
    // If path is directory or missing extension, ensure graph-store.db
    if ((fs.existsSync(dbFilePath) && fs.statSync(dbFilePath).isDirectory()) || !path.extname(dbFilePath)) {
      dbFilePath = path.join(dbFilePath, "graph-store.db");
    }

    const parentDir = path.dirname(dbFilePath);
    if (!fs.existsSync(parentDir)) {
      fs.mkdirSync(parentDir, { recursive: true });
    }

    this.dbFilePath = dbFilePath;
    console.log(`üìÅ SQLite: Using database file: ${dbFilePath}`);

    try {
      // Locate WASM
      const extensionPath = path.dirname(path.dirname(path.dirname(path.dirname(__dirname))));
      const wasmPath = path.join(extensionPath, "src", "assets", "sql-wasm.wasm");

      const SQL = await initSqlJs({
        locateFile: (file) => (file.endsWith(".wasm") ? wasmPath : file),
      });
      this.SQL = SQL;

      let buffer: Uint8Array | undefined;
      if (fs.existsSync(dbFilePath)) {
        buffer = fs.readFileSync(dbFilePath);
      }

      this.db = new SQL.Database(buffer);
      this.db.run("PRAGMA foreign_keys = ON");
      this.createSchema();
      this.saveToFile();
      console.log("‚úÖ SQLite: Database initialized");
    } catch (error) {
      console.error("‚ùå SQLite initialization error:", error);
      throw new Error(`Failed to initialize SQLite: ${error}`);
    }
  }

  async reloadFromDisk(): Promise<void> {
    if (!this.SQL) return;
    try {
      let buffer: Uint8Array | undefined;
      if (fs.existsSync(this.dbFilePath)) {
        buffer = fs.readFileSync(this.dbFilePath);
      }
      if (this.db) this.db.close();
      this.db = new this.SQL.Database(buffer);
      this.db.run("PRAGMA foreign_keys = ON");
      this.createSchema();
      console.log("üîÑ SQLite: Reloaded database from disk");
    } catch (error) {
      console.error("‚ùå SQLite reloadFromDisk error:", error);
    }
  }

  private createSchema(): void {
    if (!this.db) return;
    
    // Nodes table - Hybrid schema with structured + dynamic discovery fields
    this.db.run(`
      CREATE TABLE IF NOT EXISTS nodes (
        id TEXT PRIMARY KEY,
        tenant_id TEXT NOT NULL DEFAULT 'default',
        type TEXT NOT NULL,
        label TEXT NOT NULL,
        status TEXT DEFAULT 'active',
        
        -- Dynamic Discovery (LightRAG-inspired)
        discovered_type TEXT,
        discovered_properties TEXT,
        entity_confidence REAL,
        
        -- Quality & versioning
        quality_score REAL DEFAULT 1.0,
        content_hash TEXT,
        version INTEGER DEFAULT 1,
        
        -- Timestamps
        created_at TEXT DEFAULT CURRENT_TIMESTAMP,
        updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
        
        -- Database sphere
        db_type TEXT,
        host TEXT,
        port INTEGER,
        db_name TEXT,
        db_user TEXT,
        
        -- DB Entity sphere
        entity_type TEXT,
        entity_name TEXT,
        entity_schema TEXT,
        db_id TEXT,
        
        -- Code sphere
        project_path TEXT,
        file_path TEXT,
        line_start INTEGER,
        line_end INTEGER,
        chunk_type TEXT,
        symbol_name TEXT,
        symbol_kind TEXT,
        language TEXT,
        
        -- Documentation sphere
        doc_type TEXT,
        doc_url TEXT,
        doc_format TEXT,
        
        -- Issue sphere
        issue_source TEXT,
        issue_url TEXT,
        issue_status TEXT,
        issue_priority TEXT,
        
        -- Person sphere
        person_role TEXT,
        person_email TEXT,
        person_external_id TEXT,
        
        -- Cappy Task sphere
        cappy_task_status TEXT,
        cappy_task_type TEXT,
        
        -- Extensibility
        extra_metadata TEXT
      )
    `);
    
    // Edges table - Hybrid with dynamic relationship discovery
    this.db.run(`
      CREATE TABLE IF NOT EXISTS edges (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        tenant_id TEXT NOT NULL DEFAULT 'default',
        from_id TEXT NOT NULL,
        to_id TEXT NOT NULL,
        type TEXT NOT NULL,
        
        -- Dynamic Discovery
        discovered_relationship_type TEXT,
        semantic_context TEXT,
        relationship_confidence REAL,
        
        -- Metadata
        context TEXT,
        confidence REAL DEFAULT 1.0,
        quality_score REAL DEFAULT 1.0,
        status TEXT DEFAULT 'active',
        
        -- Timestamps
        created_at TEXT DEFAULT CURRENT_TIMESTAMP,
        updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
        
        -- Extensibility
        extra_metadata TEXT,
        
        UNIQUE(tenant_id, from_id, to_id, type)
      )
    `);
    
    // Vectors table - for semantic search
    this.db.run(`
      CREATE TABLE IF NOT EXISTS vectors (
        chunk_id TEXT PRIMARY KEY,
        tenant_id TEXT NOT NULL DEFAULT 'default',
        content TEXT NOT NULL,
        embedding_json TEXT NOT NULL,
        embedding_model TEXT,
        metadata TEXT,
        created_at TEXT DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Create indices for performance
    this.db.run(`CREATE INDEX IF NOT EXISTS idx_nodes_type ON nodes(type)`);
    this.db.run(`CREATE INDEX IF NOT EXISTS idx_nodes_tenant_type ON nodes(tenant_id, type)`);
    this.db.run(`CREATE INDEX IF NOT EXISTS idx_nodes_discovered_type ON nodes(discovered_type)`);
    this.db.run(`CREATE INDEX IF NOT EXISTS idx_nodes_file_path ON nodes(file_path)`);
    this.db.run(`CREATE INDEX IF NOT EXISTS idx_nodes_symbol_name ON nodes(symbol_name)`);
    this.db.run(`CREATE INDEX IF NOT EXISTS idx_edges_from_id ON edges(from_id)`);
    this.db.run(`CREATE INDEX IF NOT EXISTS idx_edges_to_id ON edges(to_id)`);
    this.db.run(`CREATE INDEX IF NOT EXISTS idx_edges_type ON edges(type)`);
    this.db.run(`CREATE INDEX IF NOT EXISTS idx_vectors_tenant ON vectors(tenant_id)`);
  }

  private saveToFile(): void {
    if (!this.db) return;
    const data = this.db.export();
    fs.writeFileSync(this.dbFilePath, Buffer.from(data));
  }

  async getSubgraph(
    seeds: string[] | undefined,
    depth: number,
    maxNodes = 1000
  ): Promise<{
    nodes: Array<{ id: string; label: string; type: "file" | "chunk" | "workspace" }>;
    edges: Array<{ id: string; source: string; target: string; label?: string; type: string }>;
  }> {
    if (!this.db) throw new Error("SQLite not initialized");

    const nodes: Array<{ id: string; label: string; type: "file" | "chunk" | "workspace" }> = [];
    const edges: Array<{ id: string; source: string; target: string; label?: string; type: string }> = [];
    const visited = new Set<string>();

    try {
      let currentLevel: string[] = [];
      if (!seeds || seeds.length === 0) {
        // Include both files and chunks as potential starting points
        const rootResult = this.db.exec(`SELECT id FROM nodes WHERE type IN ('file', 'chunk') LIMIT ?`, [maxNodes]);
        if (rootResult.length > 0 && rootResult[0].values) {
          currentLevel = rootResult[0].values.map((row) => row[0] as string);
        }
      } else {
        currentLevel = seeds;
      }

      for (let level = 0; level <= depth && currentLevel.length > 0; level++) {
        const nextLevel = new Set<string>();
        for (const nodeId of currentLevel) {
          if (visited.has(nodeId)) continue;
          visited.add(nodeId);

          const nodeResult = this.db.exec(`SELECT id, type, label FROM nodes WHERE id = ?`, [nodeId]);
          if (nodeResult.length > 0 && nodeResult[0].values && nodeResult[0].values.length > 0) {
            const row = nodeResult[0].values[0];
            nodes.push({ id: row[0] as string, type: row[1] as "file" | "chunk" | "workspace", label: row[2] as string });
          }

          const outEdges = this.db.exec(`SELECT id, from_id, to_id, type FROM edges WHERE from_id = ?`, [nodeId]);
          if (outEdges.length > 0 && outEdges[0].values) {
            for (const edgeRow of outEdges[0].values) {
              const targetId = edgeRow[2] as string;
              edges.push({ id: `edge-${edgeRow[0]}`, source: edgeRow[1] as string, target: targetId, type: edgeRow[3] as string, label: edgeRow[3] as string });
              if (!visited.has(targetId) && level < depth) nextLevel.add(targetId);
            }
          }

          const inEdges = this.db.exec(`SELECT id, from_id, to_id, type FROM edges WHERE to_id = ?`, [nodeId]);
          if (inEdges.length > 0 && inEdges[0].values) {
            for (const edgeRow of inEdges[0].values) {
              const sourceId = edgeRow[1] as string;
              edges.push({ id: `edge-${edgeRow[0]}`, source: sourceId, target: edgeRow[2] as string, type: edgeRow[3] as string, label: edgeRow[3] as string });
              if (!visited.has(sourceId) && level < depth) nextLevel.add(sourceId);
            }
          }

          if (nodes.length >= maxNodes) break;
        }

        currentLevel = Array.from(nextLevel);
        if (nodes.length >= maxNodes) break;
      }

      const uniqueEdges = new Map<string, (typeof edges)[number]>();
      for (const e of edges) {
        const key = `${e.source}->${e.target}:${e.type}`;
        if (!uniqueEdges.has(key)) uniqueEdges.set(key, e);
      }

      return { nodes, edges: Array.from(uniqueEdges.values()) };
    } catch (error) {
      console.error("‚ùå SQLite getSubgraph error:", error);
      return { nodes: [], edges: [] };
    }
  }

  async createFileNode(filePath: string, language: string, linesOfCode: number): Promise<void> {
    if (!this.db) throw new Error("SQLite not initialized");
    // Avoid unused parameter warning in current schema
    void linesOfCode;
    this.db.run(
      `INSERT OR REPLACE INTO nodes (id, type, label, language, file_path) 
       VALUES (?, ?, ?, ?, ?)`,
      [filePath, "file", path.basename(filePath), language, filePath]
    );
    this.saveToFile();
  }

  async createChunkNodes(chunks: DocumentChunk[]): Promise<void> {
    if (!this.db) throw new Error("SQLite not initialized");
    for (const chunk of chunks) {
      const label = chunk.metadata.symbolName || `${chunk.metadata.chunkType} [${chunk.metadata.lineStart}-${chunk.metadata.lineEnd}]`;
      
      this.db.run(
        `INSERT OR REPLACE INTO nodes 
         (id, type, label, file_path, line_start, line_end, chunk_type, symbol_name, symbol_kind) 
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          chunk.id,
          "chunk",
          label,
          chunk.metadata.filePath,
          chunk.metadata.lineStart,
          chunk.metadata.lineEnd,
          chunk.metadata.chunkType,
          chunk.metadata.symbolName || null,
          chunk.metadata.symbolKind || null
        ]
      );
    }
    this.saveToFile();
  }

  async createRelationships(relationships: Array<{ from: string; to: string; type: string; properties?: Record<string, string | number | boolean | string[] | null> }>): Promise<void> {
    if (!this.db) throw new Error("SQLite not initialized");
    if (relationships.length === 0) return;
    
    for (const rel of relationships) {
      try {
        // Extract common fields from properties
        const confidence = typeof rel.properties?.confidence === 'number' ? rel.properties.confidence : 1.0;
        const context = typeof rel.properties?.context === 'string' ? rel.properties.context : null;
        
        // Keep remaining properties in extra_metadata
        const extraMetadata = rel.properties ? JSON.stringify(rel.properties) : null;
        
        this.db.run(
          `INSERT OR IGNORE INTO edges (from_id, to_id, type, confidence, context, extra_metadata) 
           VALUES (?, ?, ?, ?, ?, ?)`,
          [rel.from, rel.to, rel.type, confidence, context, extraMetadata]
        );
      } catch (error) {
        console.error(`‚ùå Failed to create edge: ${rel.type} from ${rel.from} to ${rel.to}`, error);
      }
    }
    this.saveToFile();
  }

  async getRelatedChunks(ids: string[], depth = 1): Promise<string[]> {
    if (!this.db || !ids || ids.length === 0) return [];
    try {
      const related: Set<string> = new Set();
      const fileIds: Set<string> = new Set();
      const fileStmt = this.db.prepare(`SELECT from_id FROM edges WHERE to_id = ? AND type = 'CONTAINS' LIMIT 1`);
      for (const chunkId of ids) {
        fileStmt.bind([chunkId]);
        if (fileStmt.step()) {
          const row = fileStmt.getAsObject() as Record<string, unknown>;
          const fid = String(row["from_id"] ?? "");
          if (fid) fileIds.add(fid);
        }
        fileStmt.reset();
      }
      fileStmt.free();

      if (fileIds.size > 0) {
        const placeholders = Array.from(fileIds).map(() => "?").join(",");
        const sibStmt = this.db.prepare(`SELECT to_id FROM edges WHERE from_id IN (${placeholders}) AND type = 'CONTAINS'`);
        sibStmt.bind(Array.from(fileIds));
        while (sibStmt.step()) {
          const row = sibStmt.getAsObject() as Record<string, unknown>;
          const cid = String(row["to_id"] ?? "");
          if (cid && !ids.includes(cid)) related.add(cid);
        }
        sibStmt.free();
      }

      if (depth > 1) {
        const placeholders = ids.map(() => "?").join(",");
        const docsStmt = this.db.prepare(
          `SELECT to_id AS nid FROM edges WHERE from_id IN (${placeholders}) AND type = 'DOCUMENTS'
           UNION SELECT from_id AS nid FROM edges WHERE to_id IN (${placeholders}) AND type = 'DOCUMENTS'`
        );
        docsStmt.bind([...ids, ...ids]);
        while (docsStmt.step()) {
          const row = docsStmt.getAsObject() as Record<string, unknown>;
          const nid = String(row["nid"] ?? "");
          if (nid && !ids.includes(nid)) related.add(nid);
        }
        docsStmt.free();
      }

      return Array.from(related);
    } catch (error) {
      console.error("‚ùå SQLite getRelatedChunks error:", error);
      return [];
    }
  }

  async deleteFileNodes(filePath: string): Promise<void> {
    if (!this.db) throw new Error("SQLite not initialized");
    // Delete edges connected to the file node
    this.db.run(`DELETE FROM edges WHERE from_id = ? OR to_id = ?`, [filePath, filePath]);
    // Collect chunk ids that belong to this file
    const res = this.db.exec(`SELECT id FROM nodes WHERE type = 'chunk' AND file_path = ?`, [filePath]);
    const chunkIds = res.length > 0 && res[0].values ? res[0].values.map(v => String(v[0])) : [];
    // Delete edges connected to those chunks
    for (const cid of chunkIds) {
      this.db.run(`DELETE FROM edges WHERE from_id = ? OR to_id = ?`, [cid, cid]);
    }
    // Delete chunk nodes for the file
    this.db.run(`DELETE FROM nodes WHERE type = 'chunk' AND file_path = ?`, [filePath]);
    // Finally delete the file node
    this.db.run(`DELETE FROM nodes WHERE id = ? AND type = 'file'`, [filePath]);
    this.saveToFile();
  }

  async deleteFile(filePath: string): Promise<void> {
    return this.deleteFileNodes(filePath);
  }

  async listAllFiles(): Promise<Array<{ path: string; language: string; linesOfCode: number }>> {
    if (!this.db) return [];
    const result = this.db.exec(`SELECT id, language FROM nodes WHERE type = 'file'`);
    if (result.length === 0 || !result[0].values) return [];
    return result[0].values.map((row) => ({
      path: row[0] as string,
      language: (row[1] as string) || "",
      linesOfCode: 0,
    }));
  }

  async getFileChunks(filePath: string): Promise<Array<{ id: string; type: string; label: string }>> {
    if (!this.db) return [];
    const result = this.db.exec(
      `SELECT DISTINCT n.id, n.type, n.label FROM nodes n INNER JOIN edges e ON e.to_id = n.id WHERE e.from_id = ? AND e.type = 'CONTAINS' AND n.type = 'chunk'`,
      [filePath]
    );
    if (result.length === 0 || !result[0].values) return [];
    return result[0].values.map((row) => ({ id: row[0] as string, type: row[1] as string, label: row[2] as string }));
  }

  async close(): Promise<void> {
    if (this.db) {
      this.saveToFile();
      this.db.close();
      this.db = null;
    }
  }

  getStats() {
    if (!this.db) return { fileNodes: 0, chunkNodes: 0, relationships: 0, duplicates: 0 };
    try {
      const fileResult = this.db.exec(`SELECT COUNT(*) FROM nodes WHERE type = 'file'`);
      const chunkResult = this.db.exec(`SELECT COUNT(*) FROM nodes WHERE type = 'chunk'`);
      const edgeResult = this.db.exec(`SELECT COUNT(*) FROM edges`);
      const dupResult = this.db.exec(`
        SELECT COUNT(*) as dup_count FROM (
          SELECT id, COUNT(*) as count FROM nodes GROUP BY id HAVING count > 1
        )
      `);
      const duplicates = (dupResult[0]?.values[0]?.[0] as number) || 0;
      return {
        fileNodes: (fileResult[0]?.values[0][0] as number) || 0,
        chunkNodes: (chunkResult[0]?.values[0][0] as number) || 0,
        relationships: (edgeResult[0]?.values[0][0] as number) || 0,
        duplicates,
      };
    } catch (error) {
      console.error("‚ùå SQLite getStats error:", error);
      return { fileNodes: 0, chunkNodes: 0, relationships: 0, duplicates: 0 };
    }
  }

  async ensureWorkspaceNode(name: string): Promise<void> {
    if (!this.db) throw new Error("SQLite not initialized");
    this.db.run(`INSERT OR IGNORE INTO nodes (id, type, label) VALUES (?, ?, ?)`, [
      `workspace:${name}`,
      "workspace",
      name,
    ]);
    this.saveToFile();
  }

  async storeEmbeddings(chunks: Array<{ id: string; content: string; embedding: number[]; metadata?: Record<string, unknown> }>): Promise<void> {
    if (!this.db) return;
    for (const chunk of chunks) {
      this.db.run(
        `INSERT OR REPLACE INTO vectors (chunk_id, content, embedding_json, metadata) VALUES (?, ?, ?, ?)`,
        [chunk.id, chunk.content, JSON.stringify(chunk.embedding), chunk.metadata ? JSON.stringify(chunk.metadata) : null]
      );
    }
    this.saveToFile();
  }

  async searchSimilar(
    _queryEmbedding: number[],
    limit = 10
  ): Promise<Array<{ id: string; content: string; score: number; metadata?: Record<string, unknown> }>> {
    if (!this.db) return [];
    const dot = (a: number[], b: number[]) => a.reduce((s, v, i) => s + v * (b[i] ?? 0), 0);
    const norm = (a: number[]) => Math.sqrt(a.reduce((s, v) => s + v * v, 0));
    try {
      const result = this.db.exec(`SELECT chunk_id, content, embedding_json, metadata FROM vectors`);
      if (result.length === 0 || !result[0].values) return [];
      const qn = norm(_queryEmbedding) || 1e-9;
      const rows = result[0].values;
      const scored = rows.map((row) => {
        const id = row[0] as string;
        const content = row[1] as string;
        const emb = JSON.parse(row[2] as string) as number[];
        const metadata = row[3] ? JSON.parse(row[3] as string) : undefined;
        const score = dot(_queryEmbedding, emb) / (qn * (norm(emb) || 1e-9));
        return { id, content, score, metadata };
      });
      scored.sort((a, b) => b.score - a.score);
      return scored.slice(0, Math.max(0, limit));
    } catch (error) {
      console.error("‚ùå SQLite searchSimilar error:", error);
      return [];
    }
  }

  async getChunksByIds(ids: string[]): Promise<DocumentChunk[]> {
    if (!this.db) return [];
    if (!ids || ids.length === 0) return [];
    try {
      const placeholders = ids.map(() => "?").join(",");
      const query = `SELECT chunk_id, content, metadata FROM vectors WHERE chunk_id IN (${placeholders})`;
      const result = this.db.exec(query, ids as unknown as string[]);
      if (result.length === 0 || !result[0].values) return [];
      const rows = result[0].values;
      const chunks: DocumentChunk[] = rows.map((row) => {
        const id = row[0] as string;
        const content = row[1] as string;
        const metadataRaw = row[2] as string | null;
        const meta = metadataRaw ? (JSON.parse(metadataRaw) as Record<string, unknown>) : {};
        return {
          id,
          content,
          metadata: {
            filePath: (meta.filePath as string) || "",
            lineStart: (meta.lineStart as number) ?? 0,
            lineEnd: (meta.lineEnd as number) ?? 0,
            chunkType: (meta.chunkType as DocumentChunk["metadata"]["chunkType"]) || "plain_text",
            symbolName: meta.symbolName as string | undefined,
            symbolKind: meta.symbolKind as DocumentChunk["metadata"]["symbolKind"] | undefined,
          },
        };
      });
      return chunks;
    } catch (error) {
      console.error("‚ùå SQLite getChunksByIds error:", error);
      return [];
    }
  }

  async getSampleRelationships(limit = 20): Promise<Array<{
    id: number;
    from: string;
    to: string;
    type: string;
    properties?: Record<string, unknown>;
  }>> {
    if (!this.db) return [];
    try {
      const result = this.db.exec(`SELECT id, from_id, to_id, type, extra_metadata FROM edges LIMIT ${limit}`);
      if (result.length === 0 || !result[0].values) return [];
      return result[0].values.map((row) => ({
        id: row[0] as number,
        from: row[1] as string,
        to: row[2] as string,
        type: row[3] as string,
        properties: row[4] ? JSON.parse(row[4] as string) : undefined,
      }));
    } catch (error) {
      console.error("Error fetching sample relationships:", error);
      return [];
    }
  }

  async getRelationshipsByType(): Promise<Record<string, Array<{ from: string; to: string; properties?: Record<string, unknown> }>>> {
    if (!this.db) return {};
    try {
      const result = this.db.exec(`SELECT type, from_id, to_id, extra_metadata FROM edges ORDER BY type`);
      if (result.length === 0 || !result[0].values) return {};
      const grouped: Record<string, Array<{ from: string; to: string; properties?: Record<string, unknown> }>> = {};
      for (const row of result[0].values) {
        const type = row[0] as string;
        const from = row[1] as string;
        const to = row[2] as string;
        const properties = row[3] ? JSON.parse(row[3] as string) : undefined;
        if (!grouped[type]) grouped[type] = [];
        grouped[type].push({ from, to, properties });
      }
      return grouped;
    } catch (error) {
      console.error("Error fetching relationships by type:", error);
      return {};
    }
  }

  // ============================================================
  // NEW SPHERE METHODS - Hybrid Schema V2
  // ============================================================

  /**
   * Creates a database node (Sphere 1: Database)
   */
  async createDatabaseNode(params: {
    id: string;
    label: string;
    dbType: string;
    host: string;
    port: number;
    dbName: string;
    user?: string;
  }): Promise<void> {
    if (!this.db) throw new Error("SQLite not initialized");
    
    this.db.run(
      `INSERT OR REPLACE INTO nodes 
       (id, type, label, db_type, host, port, db_name, db_user) 
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      [params.id, 'database', params.label, params.dbType, params.host, params.port, params.dbName, params.user || null]
    );
    this.saveToFile();
  }

  /**
   * Creates a database entity node (table, procedure, function, etc.)
   */
  async createDbEntityNode(params: {
    id: string;
    label: string;
    entityType: 'table' | 'view' | 'procedure' | 'function' | 'trigger';
    entityName: string;
    entitySchema?: string;
    dbId: string;
    discoveredType?: string;
    discoveredProperties?: Record<string, unknown>;
    confidence?: number;
  }): Promise<void> {
    if (!this.db) throw new Error("SQLite not initialized");
    
    this.db.run(
      `INSERT OR REPLACE INTO nodes 
       (id, type, label, entity_type, entity_name, entity_schema, db_id, 
        discovered_type, discovered_properties, entity_confidence) 
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        params.id,
        'db_entity',
        params.label,
        params.entityType,
        params.entityName,
        params.entitySchema || null,
        params.dbId,
        params.discoveredType || null,
        params.discoveredProperties ? JSON.stringify(params.discoveredProperties) : null,
        params.confidence || null
      ]
    );
    this.saveToFile();
  }

  /**
   * Creates an issue node (GitHub, Jira, local, etc.)
   */
  async createIssueNode(params: {
    id: string;
    label: string;
    source: 'github' | 'jira' | 'local' | 'linear';
    url?: string;
    status: string;
    priority?: string;
    discoveredProperties?: Record<string, unknown>;
  }): Promise<void> {
    if (!this.db) throw new Error("SQLite not initialized");
    
    this.db.run(
      `INSERT OR REPLACE INTO nodes 
       (id, type, label, issue_source, issue_url, issue_status, issue_priority, discovered_properties) 
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        params.id,
        'issue',
        params.label,
        params.source,
        params.url || null,
        params.status,
        params.priority || null,
        params.discoveredProperties ? JSON.stringify(params.discoveredProperties) : null
      ]
    );
    this.saveToFile();
  }

  /**
   * Creates a person node (developer, analyst, manager, LLM agent)
   */
  async createPersonNode(params: {
    id: string;
    label: string;
    role: 'developer' | 'analyst' | 'manager' | 'llm_agent';
    email?: string;
    externalId?: string;
    discoveredProperties?: Record<string, unknown>;
  }): Promise<void> {
    if (!this.db) throw new Error("SQLite not initialized");
    
    this.db.run(
      `INSERT OR REPLACE INTO nodes 
       (id, type, label, person_role, person_email, person_external_id, discovered_properties) 
       VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [
        params.id,
        'person',
        params.label,
        params.role,
        params.email || null,
        params.externalId || null,
        params.discoveredProperties ? JSON.stringify(params.discoveredProperties) : null
      ]
    );
    this.saveToFile();
  }

  /**
   * Creates a Cappy task node (history of Cappy tasks)
   */
  async createCappyTaskNode(params: {
    id: string;
    label: string;
    taskType: string;
    status: 'pending' | 'running' | 'completed' | 'failed';
    discoveredProperties?: Record<string, unknown>;
  }): Promise<void> {
    if (!this.db) throw new Error("SQLite not initialized");
    
    this.db.run(
      `INSERT OR REPLACE INTO nodes 
       (id, type, label, cappy_task_type, cappy_task_status, discovered_properties) 
       VALUES (?, ?, ?, ?, ?, ?)`,
      [
        params.id,
        'cappy_task',
        params.label,
        params.taskType,
        params.status,
        params.discoveredProperties ? JSON.stringify(params.discoveredProperties) : null
      ]
    );
    this.saveToFile();
  }

  /**
   * Creates a documentation node
   */
  async createDocumentationNode(params: {
    id: string;
    label: string;
    docType: 'api_doc' | 'tutorial' | 'architecture' | 'manual';
    docUrl?: string;
    docFormat?: 'markdown' | 'pdf' | 'html' | 'docx';
    discoveredType?: string;
    discoveredProperties?: Record<string, unknown>;
  }): Promise<void> {
    if (!this.db) throw new Error("SQLite not initialized");
    
    this.db.run(
      `INSERT OR REPLACE INTO nodes 
       (id, type, label, doc_type, doc_url, doc_format, discovered_type, discovered_properties) 
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        params.id,
        'documentation',
        params.label,
        params.docType,
        params.docUrl || null,
        params.docFormat || null,
        params.discoveredType || null,
        params.discoveredProperties ? JSON.stringify(params.discoveredProperties) : null
      ]
    );
    this.saveToFile();
  }

  /**
   * Updates a node with discovered entity information
   */
  async enrichNodeWithDiscovery(
    nodeId: string,
    discoveredType: string,
    discoveredProperties: Record<string, unknown>,
    confidence: number
  ): Promise<void> {
    if (!this.db) throw new Error("SQLite not initialized");
    
    this.db.run(
      `UPDATE nodes 
       SET discovered_type = ?, discovered_properties = ?, entity_confidence = ?, updated_at = CURRENT_TIMESTAMP
       WHERE id = ?`,
      [discoveredType, JSON.stringify(discoveredProperties), confidence, nodeId]
    );
    this.saveToFile();
  }

  /**
   * Creates a dynamic relationship with semantic context
   */
  async createDynamicRelationship(params: {
    from: string;
    to: string;
    type: string;
    discoveredType: string;
    semanticContext: string;
    confidence: number;
  }): Promise<void> {
    if (!this.db) throw new Error("SQLite not initialized");
    
    this.db.run(
      `INSERT OR IGNORE INTO edges 
       (from_id, to_id, type, discovered_relationship_type, semantic_context, relationship_confidence, confidence) 
       VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [params.from, params.to, params.type, params.discoveredType, params.semanticContext, params.confidence, params.confidence]
    );
    this.saveToFile();
  }

  /**
   * Creates or updates an entity node in the graph
   */
  async createEntity(entity: {
    name: string;
    type: string;
    confidence: number;
    properties: Record<string, unknown>;
  }): Promise<string> {
    if (!this.db) throw new Error("SQLite not initialized");
    
    const entityId = `entity:${entity.name.toLowerCase().replace(/\s+/g, '-')}`;
    
    this.db.run(
      `INSERT OR REPLACE INTO nodes 
       (id, type, label, discovered_type, discovered_properties, entity_confidence, status) 
       VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [
        entityId,
        'entity',
        entity.name,
        entity.type,
        JSON.stringify(entity.properties),
        entity.confidence,
        'active'
      ]
    );
    this.saveToFile();
    return entityId;
  }

  /**
   * Finds an entity by normalized name and type
   */
  async findEntityByNameAndType(name: string, type: string | undefined): Promise<{ id: string } | null> {
    if (!this.db) throw new Error("SQLite not initialized");
    
    const query = type 
      ? `SELECT id FROM nodes WHERE type = 'entity' AND LOWER(label) = ? AND discovered_type = ? LIMIT 1`
      : `SELECT id FROM nodes WHERE type = 'entity' AND LOWER(label) = ? LIMIT 1`;
    
    const params = type ? [name.toLowerCase(), type] : [name.toLowerCase()];
    const result = this.db.exec(query, params);
    
    if (result.length > 0 && result[0].values.length > 0) {
      return { id: result[0].values[0][0] as string };
    }
    return null;
  }

  /**
   * Links a chunk to an entity
   */
  async linkChunkToEntity(chunkId: string, entityId: string): Promise<void> {
    if (!this.db) throw new Error("SQLite not initialized");
    
    this.db.run(
      `INSERT OR IGNORE INTO edges 
       (from_id, to_id, type, confidence) 
       VALUES (?, ?, ?, ?)`,
      [chunkId, entityId, 'references', 1.0]
    );
    this.saveToFile();
  }

  /**
   * Creates a relationship between two entities
   */
  async createRelationship(rel: {
    from: string;
    to: string;
    type: string;
    properties?: Record<string, unknown>;
  }): Promise<void> {
    if (!this.db) throw new Error("SQLite not initialized");
    
    const confidence = rel.properties?.confidence as number || 1.0;
    const context = rel.properties?.context as string || '';
    
    this.db.run(
      `INSERT OR IGNORE INTO edges 
       (from_id, to_id, type, semantic_context, confidence) 
       VALUES (?, ?, ?, ?, ?)`,
      [rel.from, rel.to, rel.type, context, confidence]
    );
    this.saveToFile();
  }

  /**
   * Clear all data from database (memory and disk)
   */
  async clearAll(): Promise<void> {
    if (!this.db) throw new Error("SQLite not initialized");
    
    console.log('üóëÔ∏è Clearing all data from graph database...');
    
    // Delete all data from memory
    this.db.run('DELETE FROM edges');
    this.db.run('DELETE FROM nodes');
    this.db.run('DELETE FROM vectors');
    
    // Persist empty database to disk
    this.saveToFile();
    
    console.log('‚úÖ Graph database cleared (memory + disk)');
  }
}

export function createSQLiteAdapter(dbPath: string): GraphStorePort {
  return new SQLiteAdapter(dbPath);
}

