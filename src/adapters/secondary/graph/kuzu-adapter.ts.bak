/**
 * @fileoverview Kuzu adapter for graph storage
 * @module adapters/secondary/graph/kuzu-adapter
 * @author Cappy Team
 * @since 3.0.0
 */

import kuzu from 'kuzu-wasm';
import type { GraphStorePort } from '../../../domains/graph/ports/indexing-port';
import type { DocumentChunk } from '../../../types/chunk';
import type { ChunkNode } from '../../../types/chunk';

/**
 * Kuzu adapter implementing GraphStorePort using kuzu-wasm
 */
export class KuzuAdapter implements GraphStorePort {
  private readonly dbPath: string;
  private db: any = null;
  private conn: any = null;
  private initialized = false;

  constructor(dbPath: string) {
    this.dbPath = dbPath;
  }

  /**
   * Initializes the Kuzu database connection and creates schema
   */
  async initialize(): Promise<void> {
    try {
      console.log(`üìä Initializing Kuzu database at: ${this.dbPath}`);
      
      // Create database (will reuse if exists)
      this.db = new kuzu.Database(this.dbPath);
      this.conn = new kuzu.Connection(this.db);

      // Create schema for File nodes
      await this.conn.query(`
        CREATE NODE TABLE IF NOT EXISTS File (
          path STRING PRIMARY KEY,
          language STRING,
          linesOfCode INT64
        )
      `);

      // Create schema for Chunk nodes
      await this.conn.query(`
        CREATE NODE TABLE IF NOT EXISTS Chunk (
          id STRING PRIMARY KEY,
          filePath STRING,
          lineStart INT64,
          lineEnd INT64,
          chunkType STRING,
          symbolName STRING,
          symbolKind STRING
        )
      `);

      // Create schema for Workspace nodes
      await this.conn.query(`
        CREATE NODE TABLE IF NOT EXISTS Workspace (
          name STRING PRIMARY KEY
        )
      `);

      // Create relationships
      await this.conn.query(`
        CREATE REL TABLE IF NOT EXISTS CONTAINS (
          FROM File TO Chunk,
          order INT64
        )
      `);

      await this.conn.query(`
        CREATE REL TABLE IF NOT EXISTS DOCUMENTS (
          FROM Chunk TO Chunk
        )
      `);

      await this.conn.query(`
        CREATE REL TABLE IF NOT EXISTS BELONGS_TO (
          FROM File TO Workspace
        )
      `);

      this.initialized = true;
      console.log('‚úÖ Kuzu: Database initialized with schema');
    } catch (error) {
      console.error('‚ùå Kuzu initialization error:', error);
      throw new Error(`Failed to initialize Kuzu: ${error}`);
    }
  }

  /**
   * Returns a subgraph expanded from seed nodes up to a given depth.
   * If no seeds are provided, starts from up to the first file node.
   */
  async getSubgraph(seeds: string[] | undefined, depth: number, maxNodes = 1000): Promise<{
    nodes: Array<{ id: string; label: string; type: 'file' | 'chunk' }>
    edges: Array<{ id: string; source: string; target: string; label?: string; type: string }>
  }> {
    if (!this.initialized) {
      throw new Error('Kuzu not initialized');
    }

    const startSeeds: string[] = (seeds && seeds.length > 0)
      ? seeds
      : Array.from(this.fileNodes.keys()).slice(0, 1);

    const visited = new Set<string>(startSeeds);
    const queue: string[] = [...startSeeds];
    let currentDepth = 0;

    // Build adjacency lists for faster traversal
    const outAdj = new Map<string, Array<{ to: string; type: string }>>();
    const inAdj = new Map<string, Array<{ from: string; type: string }>>();
    for (const rel of this.relationships) {
      if (!outAdj.has(rel.from)) outAdj.set(rel.from, []);
      outAdj.get(rel.from)!.push({ to: rel.to, type: rel.type });
      if (!inAdj.has(rel.to)) inAdj.set(rel.to, []);
      inAdj.get(rel.to)!.push({ from: rel.from, type: rel.type });
    }

    const includedEdges: Array<{ source: string; target: string; type: string }> = [];

    while (queue.length > 0 && currentDepth < Math.max(0, depth)) {
      const levelSize = queue.length;
      for (let i = 0; i < levelSize; i++) {
        const current = queue.shift();
        if (!current) continue;

        // Explore out edges
        const outs = outAdj.get(current) ?? [];
        for (const { to, type } of outs) {
          includedEdges.push({ source: current, target: to, type });
          if (!visited.has(to) && visited.size < maxNodes) {
            visited.add(to);
            queue.push(to);
          }
        }
        // Explore in edges (bidirectional traversal for context)
        const ins = inAdj.get(current) ?? [];
        for (const { from, type } of ins) {
          includedEdges.push({ source: from, target: current, type });
          if (!visited.has(from) && visited.size < maxNodes) {
            visited.add(from);
            queue.push(from);
          }
        }
      }
      currentDepth++;
    }

    // Materialize nodes
    const nodes: Array<{ id: string; label: string; type: 'file' | 'chunk' }> = [];
    for (const id of visited) {
      if (this.fileNodes.has(id)) {
        const file = this.fileNodes.get(id)!;
        const label = file.path.split('/').pop() || file.path;
        nodes.push({ id, label, type: 'file' });
      } else if (this.chunkNodes.has(id)) {
        const ch = this.chunkNodes.get(id)!;
        const base = ch.symbolName ?? ch.chunkType ?? 'chunk';
        const label = `${base} [${ch.lineStart}-${ch.lineEnd}]`;
        nodes.push({ id, label, type: 'chunk' });
      } else if (id === this.workspaceNodeId) {
        nodes.push({ id, label: id.replace('workspace:', ''), type: 'file' });
      }
    }

    // Materialize edges and de-duplicate
    const edgeSet = new Set<string>();
    const edges: Array<{ id: string; source: string; target: string; label?: string; type: string }> = [];
    for (const e of includedEdges) {
      if (!visited.has(e.source) || !visited.has(e.target)) continue;
      const key = `${e.source}->${e.target}:${e.type}`;
      if (edgeSet.has(key)) continue;
      edgeSet.add(key);
      edges.push({ id: key, source: e.source, target: e.target, label: e.type, type: e.type });
    }

    return { nodes, edges };
  }

  /**
   * Creates a file node
   */
  async createFileNode(path: string, language: string, linesOfCode: number): Promise<void> {
    if (!this.initialized) {
      throw new Error('Kuzu not initialized');
    }

    try {
      this.fileNodes.set(path, { path, language, linesOfCode });
      console.log(`‚úÖ Kuzu: Created file node for ${path}`);
    } catch (error) {
      console.error('‚ùå Kuzu createFileNode error:', error);
      throw new Error(`Failed to create file node: ${error}`);
    }
  }

  /**
   * Creates chunk nodes
   */
  async createChunkNodes(chunks: DocumentChunk[]): Promise<void> {
    if (!this.initialized) {
      throw new Error('Kuzu not initialized');
    }

    try {
      for (const chunk of chunks) {
        this.chunkNodes.set(chunk.id, {
          id: chunk.id,
          filePath: chunk.metadata.filePath,
          lineStart: chunk.metadata.lineStart,
          lineEnd: chunk.metadata.lineEnd,
          chunkType: chunk.metadata.chunkType,
          symbolName: chunk.metadata.symbolName,
          symbolKind: chunk.metadata.symbolKind
        });
      }
      console.log(`‚úÖ Kuzu: Created ${chunks.length} chunk nodes`);
    } catch (error) {
      console.error('‚ùå Kuzu createChunkNodes error:', error);
      throw new Error(`Failed to create chunk nodes: ${error}`);
    }
  }

  /**
   * Creates relationships between nodes
   */
  async createRelationships(
    relationships: Array<{ from: string; to: string; type: string; properties?: Record<string, string | number | boolean> }>
  ): Promise<void> {
    if (!this.initialized) {
      throw new Error('Kuzu not initialized');
    }

    try {
      this.relationships.push(...relationships);
      console.log(`‚úÖ Kuzu: Created ${relationships.length} relationships`);
    } catch (error) {
      console.error('‚ùå Kuzu createRelationships error:', error);
      throw new Error(`Failed to create relationships: ${error}`);
    }
  }

  /**
   * Queries related chunks via graph traversal
   */
  async getRelatedChunks(chunkIds: string[], depth = 2): Promise<string[]> {
    if (!this.initialized) {
      throw new Error('Kuzu not initialized');
    }

    try {
      // Simple BFS traversal in memory
      const visited = new Set<string>(chunkIds);
      const queue = [...chunkIds];
      let currentDepth = 0;

      while (queue.length > 0 && currentDepth < depth) {
        const levelSize = queue.length;
        
        for (let i = 0; i < levelSize; i++) {
          const current = queue.shift();
          if (!current) continue;

          // Find related chunks through relationships
          for (const rel of this.relationships) {
            if (rel.from === current && !visited.has(rel.to)) {
              visited.add(rel.to);
              queue.push(rel.to);
            }
            if (rel.to === current && !visited.has(rel.from)) {
              visited.add(rel.from);
              queue.push(rel.from);
            }
          }
        }
        
        currentDepth++;
      }

      // Remove original chunk IDs from results
      const related = Array.from(visited).filter(id => !chunkIds.includes(id));
      console.log(`‚úÖ Kuzu: Found ${related.length} related chunks`);
      return related;
    } catch (error) {
      console.error('‚ùå Kuzu getRelatedChunks error:', error);
      throw new Error(`Failed to get related chunks: ${error}`);
    }
  }

  /**
   * Deletes all nodes and relationships for a file
   */
  async deleteFileNodes(filePath: string): Promise<void> {
    if (!this.initialized) {
      throw new Error('Kuzu not initialized');
    }

    try {
      // Delete file node
      this.fileNodes.delete(filePath);

      // Delete chunk nodes for this file
      const chunksToDelete: string[] = [];
      for (const [id, chunk] of this.chunkNodes.entries()) {
        if (chunk.filePath === filePath) {
          chunksToDelete.push(id);
        }
      }
      
      for (const id of chunksToDelete) {
        this.chunkNodes.delete(id);
      }

      // Delete relationships involving these chunks
      this.relationships = this.relationships.filter(rel => 
        !chunksToDelete.includes(rel.from) && !chunksToDelete.includes(rel.to)
      );

      console.log(`‚úÖ Kuzu: Deleted nodes for ${filePath}`);
    } catch (error) {
      console.error('‚ùå Kuzu deleteFileNodes error:', error);
      throw new Error(`Failed to delete file nodes: ${error}`);
    }
  }

  /**
   * Closes the connection
   */
  async close(): Promise<void> {
    this.fileNodes.clear();
    this.chunkNodes.clear();
    this.relationships = [];
    this.initialized = false;
    console.log('‚úÖ Kuzu: Connection closed');
  }

  /**
   * Gets statistics for debugging
   */
  getStats() {
    return {
      fileNodes: this.fileNodes.size,
      chunkNodes: this.chunkNodes.size,
      relationships: this.relationships.length
    };
  }

  /**
   * Ensures a workspace node exists; in-memory marker for now
   */
  async ensureWorkspaceNode(name: string): Promise<void> {
    if (!this.initialized) {
      throw new Error('Kuzu not initialized');
    }
    try {
      if (!this.workspaceNodeId) {
        this.workspaceNodeId = `workspace:${name}`;
        console.log(`‚úÖ Kuzu: Workspace node created: ${this.workspaceNodeId}`);
      } else {
        console.log(`‚ÑπÔ∏è Kuzu: Workspace node exists: ${this.workspaceNodeId}`);
      }
    } catch (error) {
      console.error('‚ùå Kuzu ensureWorkspaceNode error:', error);
      throw new Error(`Failed to ensure workspace node: ${error}`);
    }
  }
}

/**
 * Factory function to create Kuzu adapter
 */
export function createKuzuAdapter(dbPath: string): GraphStorePort {
  return new KuzuAdapter(dbPath);
}
