<?xml version="1.0" encoding="UTF-8"?>
<cappy:script xmlns:cappy="https://schemas.cappy.dev" name="newtask" version="2.0">
  <about>
    <summary>Create atomic task with automatic context orchestration - CAPPY 2.0</summary>
    <command>cappy:new</command>
    <notes>
      <note>LLM creates XSD-compliant task with context discovery</note>
      <note>Natural language interpretation supported ("new task", "nova tarefa")</note>
      <note>Context orchestration automatically finds docs, rules, related tasks</note>
      <note>Requires .cappy/stack.md and context indices</note>
      <note>One question at a time for clarity</note>
      <note>Maximum 5 main steps per task (smart atomicity)</note>
    </notes>
  </about>

  <steps>
    <step id="validate-cappy-structure">
      <goal>Validate CAPPY 2.0 structure and context system</goal>
      <logic>
        1 - Check if .cappy/stack.md exists and is not empty
          1.1 - If missing or empty, alert user and abort
        2 - Verify context orchestration system is ready
          2.1 - Check .cappy/index/ directory exists
          2.2 - Check docs/ directory structure exists
          2.3 - If context system incomplete, suggest running initialization
        3 - If structure valid, proceed to next step
      </logic>
    </step>

    <step id="check-active-tasks">
      <goal>Ensure no active tasks using XSD status checking</goal>
      <logic>
        1 - Search .cappy/tasks/ for files with status="in_progress"
        2 - Check XSD namespace compliance in existing tasks
          2.1 - If non-compliant tasks found, suggest migration
        3 - If active task found, inform user and provide task status
          3.1 - Suggest completing current task before creating new one
        4 - If no active tasks, proceed to context discovery
      </logic>
    </step>

    <step id="context-discovery">
      <goal>Automatic context discovery based on user description</goal>
      <logic>
        1 - Collect task description from user in natural language
        2 - Extract keywords for context search
        3 - Perform context orchestration pipeline:
          3.1 - Semantic search in docs/ for related content
          3.2 - Infer category based on description patterns:
              - auth/login/jwt → category="auth"
              - database/sql/migration → category="database"
              - api/endpoint/route → category="api"
              - component/ui/frontend → category="ui"
              - test/spec/coverage → category="testing"
              - bug/fix/error → category="bugfix"
              - refactor/cleanup → category="refactor"
              - default → category="feature"
          3.3 - Find prevention rules by inferred category
          3.4 - Search for related tasks by context similarity
          3.5 - Extract dependencies from stack.md
        4 - Present context discovery summary to user
        5 - If context insufficient, ask 1-on-1 questions to clarify
        6 - Proceed to scope validation
      </logic>
    </step>

    <step id="scope-validation">
      <goal>Validate atomic scope with expert analysis</goal>
      <logic>
        1 - Act as systems analyst expert
        2 - Analyze task scope for atomicity (≤5 main steps)
        3 - Check for subjectivity and ambiguity
        4 - Verify clear validation criteria can be defined
        5 - Apply time estimation based on complexity
        6 - If scope too large:
          6.1 - Suggest task decomposition
          6.2 - Propose breaking into smaller atomic tasks
        7 - If scope atomic and clear, proceed to XSD generation
        8 - Ensure measurable completion criteria defined
      </logic>
    </step>

    <step id="generate-xsd-template">
      <goal>Generate XSD-compliant task template with context injection</goal>
      <logic><![CDATA[
        // Generate unique task ID
        task_id = generate_task_id();
        
        // Create XSD template with discovered context
        xsd_template = create_xsd_template({
          id: task_id,
          category: inferred_category,
          namespace: "https://cappy-methodology.dev/task/1.0",
          context: {
            description: scope_description,
            keywords: extracted_keywords,
            docs_refs: discovered_docs,
            prevention_rules: applicable_rules,
            related_tasks: similar_tasks,
            dependencies: stack_dependencies
          },
          execution: {
            estimated_duration: format_iso_duration(time_estimate),
            main_step: {
              id: "main-step",
              validation: validation_criteria,
              description: step_description,
              atomic: true
            }
          }
        });
        
        // Return template for LLM to present to user
        return xsd_template;
      ]]></logic>
      <output>task_id, xsd_template</output>
    </step>

    <step id="create-task-file">
      <goal>Create XSD task file with context injection</goal>
      <logic><![CDATA[
        // Use VS Code command to create physical file
        run_vscode("cappy.createTaskFileXSD", {
          template: xsd_template,
          category: inferred_category,
          context_data: discovered_context
        });
        
        // Read command output
        out = read_text(".cappy/output.txt");
        outpath = extract(out, "<file-path>", "</file-path>");
        created_task_id = extract(out, "<id>", "</id>");
        
        if (!outpath) {
          stop_with_message("ERROR: createTaskFileXSD failed - no file path returned");
        }
        
        // Update context indices
        update_task_index(created_task_id, {
          category: inferred_category,
          keywords: extracted_keywords,
          created: now_iso()
        });
      ]]></logic>
      <output>created_task_id, outpath</output>
    </step>

    <step id="finalize-task">
      <goal>Finalize XSD task with complete context and validation</goal>
      <logic><![CDATA[
        // Read created task file
        task_xml = read_text(outpath);
        
        // Ensure XSD compliance
        task_xml = ensure_xsd_namespace(task_xml);
        task_xml = validate_xsd_structure(task_xml);
        
        // Update task attributes
        task_xml = update_task_attributes(task_xml, {
          status: "pending",
          created: now_iso(),
          priority: "normal"
        });
        
        // Finalize context section with discovery timestamp
        task_xml = finalize_context_section(task_xml, {
          discovery_timestamp: now_iso(),
          context_quality_score: calculate_context_score(discovered_context)
        });
        
        // Initialize empty completion section
        task_xml = ensure_completion_section(task_xml);
        
        // Save finalized task
        write_file(outpath, task_xml);
        
        // Provide success feedback
        success_message = `✅ CAPPY 2.0 Task Created
        📁 ID: ${created_task_id}
        📄 File: ${outpath}
        🎯 Category: ${inferred_category}
        📚 Context: ${discovered_docs.length} docs, ${applicable_rules.length} rules
        
        💡 Next: Use 'current task' or 'work on task' to begin execution`;
        
        say(success_message);
      ]]></logic>
    </step>
  </steps>

  <context_orchestration>
    <discovery_pipeline>
      <keyword_extraction>Extract nouns, verbs, and domain terms from user description</keyword_extraction>
      <semantic_search>Find relevant docs using TF-IDF and similarity matching</semantic_search>
      <category_inference>Pattern-based classification with fallback to "feature"</category_inference>
      <rule_application>Apply prevention rules by category and severity</rule_application>
      <task_similarity>Find related tasks by keyword overlap and category</task_similarity>
    </discovery_pipeline>
    
    <xsd_structure>
      <namespace>https://cappy-methodology.dev/task/1.0</namespace>
      <required_sections>context, execution</required_sections>
      <optional_sections>completion</optional_sections>
      <validation>Schema validation before file creation</validation>
    </xsd_structure>
    
    <atomicity_rules>
      <max_main_steps>5</max_main_steps>
      <measurable_criteria>Each step must have clear validation criteria</measurable_criteria>
      <single_responsibility>One main objective per task</single_responsibility>
      <decomposition>Suggest breaking large tasks into smaller atomic ones</decomposition>
    </atomicity_rules>
  </context_orchestration>
</cappy:script>